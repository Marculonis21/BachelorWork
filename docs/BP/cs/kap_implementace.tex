\chapter{Implementace projektu} \label{chapter-implementace}
V předchozí kapitole jsme prošli funkční požadavky, očekávané od vyvíjeného
souboru programů. Následuje rozbor jednotlivých modulů, které vznikly při
vlastní implementaci. 

\paragraph{Programovací jazyk}
Celý projekt je napsána v programovacím jazyce \textbf{Python}. Cílem projektu
je vytvořit čitelnou rozšířitelnou platformu, která bude uživateli jednoduše
dostupná. Pokud uživatel bude mít potřebu vytvořené moduly jakkoli měnit nebo
rozšiřovat, implementace v Pythonu toto bez problémů umožní. Jednoduchá čitelnost Pythonu
spojená s rychlostí, jakou mohou být prováděny iterace změn, bez potřeby
zdlouhavého překladu celé knihovny, se nám zdají být dostatečně užitečné
vlastnosti pro volbu Pythonu jako jazyka pro tento projekt.

\paragraph{Struktura projektu}

%TODO: Change basic imp_graph
\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\textwidth]{../img/BP_imp_graph.pdf}
    \caption{Struktura projektu}
    \label{fig:struktura}
\end{figure}

Obrázek \ref{fig:struktura} popisuje na jaké části je projekt rozdělen.
Centrální částí je modul \emph{RoboEvo}, pomocí kterého knihovna provádí
evoluční experimenty. Tento modul se pro přehlednost a rozšiřitelnost kódu
skládá z několika menších částí -- \emph{gaAgents} (popisující agenty a vlastní
genetické operátory) a \emph{robots} (udržující jednotný způsob přístupu k
různým robotům). 

Jak popisují funkční požadavky (v sekci \ref{Specifikace-funkčnípožadavky}),
projekt umožňuje několik možných způsobů práce s naší knihovny. Dva základní
možné přístupy jsou za pomoci grafického, nebo textového rozhraní. Tyto
přístupy jsou v projektu rozděleny do~\emph{GUI} (\emph{Graphical User
Interface}) a \emph{TUI} (\emph{Text-based User Interface}) modulů. Uživatel,
který bude chtít pracovat s kódem části knihovny zaměřené na vytváření a
provádění experimentů s evolučním vývojem, se dále může zaměřit na hlavní modul
\emph{RoboEvo} (a s ním spojené pomocné moduly).

\paragraph{} 
Dále v této kapitole v sekci \ref{imp:roboevo} popíšeme centrální modul
\emph{RoboEvo} pracující s několika dalšími pomocnými moduly, jejichž
implementace popíšeme v dalších oddílech. Představíme si modul \emph{robots}
propojující roboty ze simulátoru \emph{MuJoCo} (\emph{MuJoCo} bylo popsáno v
základních pojmech v oddílu \ref{MuJoCo}) s ostatními třídami v oddílu
\ref{imp:robots}. Dále si v oddílu \ref{imp:gaAgents} představíme třídu agentů.
Popis třídy implementující vlastní genetické operátorů se nachází v oddílu
\ref{imp:gaOperators}. V sekci \ref{imp:experimentsetter} představíme třídu
\texttt{Experiment} modulu \emph{experiment\_setter}, sloužící k uchování
a~předvolbě parametrů pro experimenty, usnadňující tak provádění většího
množství experimentů. Dále si představíme moduly umožňující uživateli
práci s knihovnou buď pomocí grafického prostředí (v sekci \ref{imp:GUI}), nebo
pomocí příkazové řádky (v sekci \ref{imp:TUI}). Jako poslední (v sekci
\ref{imp:problems}) zmíníme problémy, se kterými jsme se setkali při
implementaci.

\section{RoboEvo a pomocné moduly}
V této sekci popíšeme hlavní modul \emph{RoboEvo} a jeho pomocné moduly
\emph{gaAgents}, \emph{gaOperators} a \emph{robots}. Soubor těchto modulů tvoří
hlavní část celého projektu, podporující celý proces provádění evolučních
experimentů s roboty. Vytvořené rozdělení modulů bylo zvoleno pro zlepšení
čitelnosti a zjednodušení rozšiřování kódu, kde nyní každý modul
zprostředkovává velmi specifickou roli v~procesu evolučního vývoje, a tudíž je
pro uživatele jednoduché tyto části upravovat. Tato část projektu je zároveň
zcela oddělena od zpracování uživatelského vstupu, který~do hlavního modulu
vstupuje z vnějších modulů až ve chvíli zahájení experimentu. 

\subsection{Modul RoboEvo} \label{imp:roboevo}
Modul \emph{RoboEvo} je centrální modul tohoto projektu, sloužící pro spouštění
a~běh experimentů s evolučním vývojem robotů. 

Každý experiment se skládá z několika nezávislých částí. Experiment může
využívat různé typy evolučních agentů s různými genetickými operátory a může se
snažit vyvíjet různé typy robotů. Jak bylo zmíněno výše, tyto částí jsou
pro~přehlednost, čitelnost a rozšířitelnost kódu oddělené do vlastních menších
implementací, rozšiřujících hlavní modul (jednotlivé implementace budou popsány
v~dalších oddílech). Oddělené moduly umožňují jednoduše kombinovat různé agenty
s různými roboty.

\paragraph{Implementace modulu \emph{RoboEvo}}
Tento modul obsahuje funkce sloužící jak k~inicializaci evolučních experimentů,
tak k samotnému běhu evolučních algoritmů, včetně propojení s knihovnou
\emph{Gymnasium} od Farama Foundation (popsáno v sekci \ref{Simulátory -
Porovnání}), zprostředkovávající simulaci fyzikálního prostředí pro testování
jedinců.

Hlavní funkcí, která z vnějšího vstupního prostředí (např. \emph{GUI},
\emph{TUI}, vlastní modul uživatele) přijímá parametry pro spuštění
experimentů, je funkce pojmenovaná \texttt{run\_experiment}. Povinným
parametrem této funkce jsou parametry experimentu, které jsou
vloženy do jednoduché třídy \texttt{ExperimentParams} (z modulu
\emph{experiment\_params}) obsahující následující hodnoty:

%TODO: care for params changes
\begin{itemize}
    \item \texttt{robot} -- zvolený robot z modulu \texttt{robots},
    \item \texttt{agent} -- zvolený agent z modulu \texttt{gaAgents},
    \item \texttt{population\_size} -- velikost populace jedinců v
        evolučním algoritmu,
    \item \texttt{generation\_count} -- počet generací, po které bude
        evoluční algoritmus běžet,
    \item \texttt{show\_best} -- příznak určující, zda po doběhnutí evolučního
        algoritmu \\chceme v simulovaném prostředí zobrazit řešení nejlepšího
        jedince,
    \item \texttt{save\_best} -- příznak určující, zda po doběhnutí evolučního
        algoritmu \\chceme uložit nejlepšího jedince,
    \item \texttt{save\_dir} -- cesta ke složce, kam chceme uložit data z běhu
        evolučního algoritmu (pokud neexistuje, je složka automaticky vytvořena
        po doběhnutí algoritmu),
    \item \texttt{show\_graph} -- příznak určující, zda je při běhu algoritmu
        vykreslován graf zobrazující fitness hodnoty (minimální, průměrnou a
        maximální) v jednotlivých generacích,
    \item \texttt{note} -- případná poznámka, kterou může uživatel speciálně
        odlišit název dat, ukládaných po doběhnutí algoritmu.
\end{itemize}

Funkce \texttt{run\_experiment} zpracovává tyto parametry a zajišťuje vše
potřebné pro běh experimentu. V přípravě probíhá spouštění výpočetních
jednotek pro paralelizaci testovacího prostředí (umožňující ohodnocení
populace jedinců paralelně). Následně proběhne spuštění evolučního algoritmu se
zvolenými parametry, po kterém funkce uloží data vygenerovaná evolučním
algoritmem -- fitness hodnoty jedinců v každé generaci, celou
populaci jedinců z poslední generace a~(volitelné) nejlepší řešení na konci
experimentu. Tato data jsou uložená do složky, dostupné na cestě popsané v
parametru \texttt{save\_dir}.

\paragraph{Běh evolučního algoritmu}
Funkce \texttt{run\_experiment} zajišťuje spuštění evolučního algoritmu se
zvolenými parametry. Samotný běh evolučního algoritmu je poté zajištěn funkcí
\texttt{run\_evolution}. V rámci této funkce provádíme všechny kroky evolučního
algoritmu (jak byly popsány v základních pojmech evolučních algoritmů v sekci
\ref{Evoluční algoritmy}). Navíc zde pro jedince vytváříme simulační prostředí,
ve~kterých budou jedinci testováni při výpočtu fitness.

Po výpočtu fitness přichází na řadu genetické operátory, které jsou vždy
specifické pro zvolený evoluční algoritmus. V naší implementaci jsou zvolené
operátory specifikované v třídě agenta. Podrobněji třídu agentů
popíšeme v dalším oddíle \ref{imp:gaAgents}.

V rámci této funkce se zároveň sbírají důležitá data o vývoji fitness hodnot
napříč všemi generacemi a pokud to uživatel povolil, jsou aktuální data v
průběhu algoritmu vykreslována do jednoduchého grafu.

\subsection{Modul robots} \label{imp:robots}
Pro přehledné rozdělení všech částí evolučního algoritmu, zlepšení čitelnosti a
tvorby experimentů oddělujeme i třídu popisující roboty a práci s roboty do
vlastního modulu \emph{robots}. 

\paragraph{Roboti a řízení robotů}
Roboti knihovny \emph{Gymnasium} jsou popisováni pomocí XML konfiguračních
souborů, specifikující různé vlastnosti jak samotných robotů, tak prostředí, ve
kterém se pohybují. 

Robot vznikne spojováním jednoduchých tvarů pomocí kloubů. Tyto klouby mohou
být různých typů (např. pantový, kulovitý), kde každý typ se liší počtem os, ve
kterých spojeným částem těla povoluje pohyb (např. pantový v jedné ose).
Kloubu dále můžeme nastavit povolený rozsah (úhel ve stupních), ve kterém se
bude moci pohybovat. 

Následuje ukázka konfigurace pantového kloubu (\texttt{type="hinge"}) v jednom
z~výchozích robotů. Tento kloub je pohyblivý kolem osy z (\texttt{axis="0 0
1"}), interně pojmenován \texttt{hip\_1} s rozsahem od -30 do 30 stupňů.
\begin{code}
<joint axis="0 0 1" name="hip_1" pos="0.0 0.0 0.0" range="-30 30" 
 type="hinge"/>
\end{code}

Do kloubů můžeme vložit různé aktuátory, pomocí kterého můžeme kloubem
pohybovat (\emph{MuJoCo} nabízí velké množství různých aktuátorů, jejichž celý
popis je nad rámec této práce -- více informací je možné najít v oficiální
dokumentaci \emph{MuJoCo} \citep{modeling-mujocodocumentation}). 

Většina z robotů ale využívá aktuátory jen dvou typů. Prvním je \texttt{motor}
(umožňující vedle jiných specifikovat atribut převodu motoru (\emph{gear})) --
aktuátor využitý výchozím robotem \emph{AntV3} popsán později v oddílu
\ref{imp:robots.Ant}). Následuje ukázka z~XML konfigurace tohoto robota
popisující konfiguraci aktuátor motoru. Důležitým je argument
\texttt{joint}, který přiřazuje daný aktuátor ke zvolenému kloubu a argument
\texttt{ctrlrange}, který udává rozsah hodnot (nastavení aktuátoru), která~jsou
přímo mapována na povolený rozsah kloubu.
\begin{code}
<actuator>
  <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="hip_1"   
   gear="100"/>
  ...
</actuator>
\end{code}
Druhým typem je \texttt{position} (abstrakce servomotoru), umožňující nastavit
reálný atribut \texttt{kp} (\emph{velocity feedback gain}), se kterým se můžeme
potkat při nastavování PID ovladačů (\emph{proportional-integral-derivative}).
Tento aktuátor je v práci využíván v konfiguraci vlastního robota
\emph{SpotLike} (opět popsán později). Tento typ aktuátoru jsme využili,
protože \emph{SpotLike} je již složitější robot s dvanácti stupni volnosti a
možnost ručního naladění servomotorů byla nutná. To umožnilo robotovi stabilní
postoj bez příliš velkých korekcí při změnách nastavení servomotorů (jinak
vedoucích k oscilacím).

Definovaný seznam aktuátorů (část v ukázce výše) poté v simulovaném prostředí
vytváří způsob, jak robota ovládat. V pořadí, ve kterém jsme aktuátory
definovali v XML souboru, můžeme robotovi v simulovaném prostředí posílat
seznam hodnot odpovídající délky (počet aktuátorů). Aktuátory jsou následně
nastavovány na specifikované hodnoty. Tedy například robot \emph{SpotLike} s
dvanácti stupni volnosti očekává seznam dvanácti hodnot (pokud má aktuátor
nastavenou hodnotu argumentu \texttt{ctrllimited}, tak je libovolná vstupní
hodnota vždy za běhu omezena na povolený rozsah specifikovaný argumentem
\texttt{ctrlrange}).

Ovládání robota je poté sekvence n-tic reálných čísel (kde n je počet
aktuátorů), které robotovi posíláme v každém kroku simulace. Je tedy možné si
představit, jak složité je vytvořit i pro jednoduchého robota s minimálním
počtem aktuátorů takové ovládání, které ho například rozpohybuje v určitém
směru.

\paragraph{Třída \texttt{BaseRobot}}
Modul \emph{robots} je vytvořen podobným stylem jako modul \emph{gaAgents} (v sekci
\ref{imp:gaAgents}), tedy obsahuje jednu hlavní třídu \texttt{BaseRobot},
tvořící šablonu pro odvozené třídy jednotlivých robotů. Tato implementace
zásadně zjednodušuje možné připojení vlastního robota do naší knihovny což
umožní využívat vlastní roboty v experimentech s evolučním vývojem. 

Třída \texttt{BaseRobot} obsahuje několik metod využívaných všemi odvozenými
třídami a jednu abstraktní metodu, kterou každá z odvozených tříd musí
implementovat sama (informace o robotovi, sloužící k jeho prezentaci v grafické
aplikaci -- popsané v sekci \ref{imp:GUI}). Zároveň definuje všechna pole
nesoucí informace o daném robotovi (identifikační hodnota \emph{MuJoCo}
prostředí, slovník jmen částí těla robota, které mohou být použité při
evolučním vývoji a odkaz na náhledový obrázek, zobrazující robota, pro
\emph{GUI}). Tyto informace jsou uložené o každém robotovi voláním
konstruktor rodičovské třídy s potřebnými parametry.

Následuje seznam veřejných metod základní třídy
\texttt{BaseRobot}:

\begin{itemize}
    \item \texttt{create(body\_part\_mask, individual, tmp\_file = None)}
        -- metoda,\\která na vstupu dostane argument masky částí těla
        popisující, které části budou moci být měněny evolučním algoritmem
        (seznam hodnot -- buď hodnoty \texttt{False}/0 pro části těla, které se
        nemají měnit, nebo specifikování rozsahu ve formátu \texttt{tupple} --
        \texttt{(min, max)}) a argument jedince, ze kterého získává délky části
        těla daného jedince (používané při vývoji morfologie robota). Tyto
        hodnoty metoda použije při úpravě konfiguračního XML souboru, který
        popisuje robota v simulačním prostředí, a vrací nově vytvořený soubor s
        konfigurací (pokud metoda dostane argument \texttt{tmp\_file}, tak
        konfiguraci vygeneruje do tohoto souboru),
    \item \texttt{create\_default()} -- stejná funkcionalita jako předchozí
        metoda, ale pro zjednodušení zápisu vytvoří konfiguraci robota s
        výchozím nastavením,
    \item \texttt{body\_part\_names()} -- metoda vracející jména všech
        dostupných končetin robota.
\end{itemize}

\paragraph{Konfigurace vlastního robota} \label{imp:robots:symbols}
Roboti v simulátoru \emph{MuJoCo} jsou popisování konfiguračními soubory ve
formátu XML (dokumentace k modelování v \emph{MuJoCo}
\citep{modeling-mujocodocumentation}). Pro naši implementaci využíváme tento
formát pro tvorbu šablony konfiguračních souborů, kde na místo některých
číselných hodnot v konfiguraci můžeme dosadit speciální značky, které naší
knihovně umožní konfigurační soubor upravovat za běhu algoritmu. Toto nám
umožní vytvářet experimenty, které vedle pohybu mohou zároveň vyvíjet i
morfologii robotů (např. velikost specifikovaných končetin). 

Speciální značky mohou být ve tvaru např \texttt{\$L\_FRONT(0.75)\$} nebo
\texttt{@...@}. 

Značka ohraničená symbolem $\$$ se může nacházet na pozici teoreticky libovolné
číselné hodnoty v konfiguračním souboru. Značka označuje a pojmenovává hodnotu
(zde např. interně pojmenovaná jako \texttt{L\_FRONT} s výchozí hodnotou
$0.75$), kterou bude možno zvolit pro vývoj pomocí evolučního algoritmu. 

Značka ohraničená symbolem $@$ označuje část konfiguračního souboru, která může
obsahovat základní aritmetické operace, které budou vyhodnoceny po dosazení
hodnot za všechny značky ohraničené symbolem $\$$. Umožňuje tedy provádět
jednoduché výpočty v konfiguračních souborech.

Značky jsou při vytváření robota vyhledávány pomocí regulárních výrazů
očekávajících značky předvedeného formátu.

Pokud máme vytvořenou konfiguraci robota v XML souboru (např. soubor
\emph{custom\_stick\_ant.xml}), můžeme robota jednoduše přidat mezi použitelné
roboty, vytvořením odpovídající třídy v modulu \emph{robots} (podle následující
ukázky -- tvorba robota \emph{StickAnt}). Tato třída dále potřebuje určit cestu
k náhledovému obrázku (v tomto případě \emph{Basic-Ant.jpg}) a identifikační
název \emph{MuJoCo} prostředí, ve kterém bude robot testován (nyní všichni
roboti využívají stejné prostředí -- \emph{custom/CustomEnv-v0}).

\begin{code}
class StickAnt(BaseRobot): # tvorba robota StickAnt
    def __init__(self):
        # všechny soubory se nachází ve stejné složce jako 
        # tento modul
        DIR = os.path.dirname(__file__)

        # cesta k šabloně konfiguračního souboru robota
        source_file = DIR+"/custom_stick_ant.xml"

        # cesta k náhledovému obrázku robota
        picture_path = DIR+"/Basic-Ant.jpg"


        # MuJoCo prostředí, ve kterém robot bude spuštěn
        environment_id = "custom/CustomEnv-v0"

        # 'custom/CustomEnv-v0' označuje naše prostředí 
        # vytvořené tak, aby jednoduše podporovalo všechny základní 
        # druhy robotů (bez robotů využívající NEAT)

        # volání inicializační funkce třídy BaseRobot,
        # která drží všechny informace v jednotném formátu
        super(StickAnt, self).__init__(source_file, 
                                       picture_path, 
                                       environment_id)

    # implementace vlastní abstraktní metody pro popis robota pro GUI
    @property
    def description(self):
        return """ Libovolně rozsáhlý popis robota """
\end{code}

\subsubsection{Implementovaní roboti}
Knihovna obsahuje tři implementované roboty. Roboti by měli být dostatečně
rozdílní v obtížnosti ovládání, aby se na nich mohl demonstrovat rozdíl v
efektivitě pokročilých evolučních algoritmů.

\paragraph{Robot \emph{StickAnt}} \label{imp:robots.StickAnt}
Základním robotem je robot pojmenovaný \emph{StickAnt} (ukázka na obrázku
\ref{imp:fig:robots.StickAnt}). Výchozím robotem pro jeho tělo je výchozí
\emph{AntV3} z knihovny \emph{Gymnasium}. Morfologie tohoto robota je velmi
jednoduchá. Jeho tělo se skládá z koule fungující jako torso a čtyř
jednoduchých končetin, kde každá je jedním pantovým kloubem připojena na torso.
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.4\textwidth]{../img/crop_Basic-Ant.jpg}
    \caption{Robot \emph{StickAnt}}
    \label{imp:fig:robots.StickAnt}
\end{figure}

\paragraph{Robot \emph{AntV3}} \label{imp:robots.Ant}
Jedná se o výchozího robota knihovny \emph{Gymnasium} (ukázka na obrázku
\ref{imp:fig:robots.AntV3})). Morfologie tohoto robota je pokročilejší než
morfologie robota \emph{StickAnt}. Každá noha má navíc jeden pantový kloub,
který můžeme brát jako koleno. Ovládání tohoto robota již začíná být
složitější, kvůli tomu, že robot se může převrátit a spadnout.
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.4\textwidth]{../img/crop_Ant-v3.jpg}
    \caption{Robot \emph{AntV3}}
    \label{imp:fig:robots.AntV3}
\end{figure}

\paragraph{Robot \emph{SpotLike}} \label{imp:robots.Spot}
Robot inspirovaný pokročilým robotem pojmenovaným \emph{Spot} od firmy
\emph{Boston Dynamics} (popsaný v článku \citep{guizzo2019leaps}). Jedná se o
čtyřnohého robota s morfologií těla, která připomíná psa (ukázka na obrázku
\ref{imp:fig:robots.SpotLike}). Každou nohu ovládají tři klouby (dohromady tedy
12 stupňů volnosti pro celého robota), což z tohoto robota dělá toho
nejobtížnějšího na ovládání. Čtyři vysoké nohy jsou zároveň vratké, a tudíž je
o to těžší vyvinout stabilní pohyb, který ho udrží nepadat.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.4\textwidth]{../img/crop_SpotLike.jpg}
    \caption{Robot \emph{SpotLike}}
    \label{imp:fig:robots.SpotLike}
\end{figure}

\paragraph{}

\paragraph{Roboti knihovny Gymnasium}
Naše knihovna umožňuje jednoduché přidání robotů, volně dostupných v knihovně
Gymnasium. Většina těchto robotů má ve~svém prostředí definované složitější
cíle, kterých mají dosáhnout (např. balancování kyvadla ve vertikální poloze).
Tato prostředí jsou často smysluplně využitelná pouze pro experimenty s vývoj
pomocí algoritmů neuroevoluce. Několik vybraných robotů jsou jako ukázky již
implementováni v naší knihovně -- \emph{Walker2D}, \emph{InvertedPendulum},
\emph{InvertedDoublePendulum}.

\subsection{Modul \emph{gaAgents}} \label{imp:gaAgents}
Modul \emph{gaAgents} je kolekcí několika tříd popisující agenty využívané
evolučními algoritmy. Každá třída agenta povinně obsahuje několik funkcí, které
specifikují, jak vypadá genotyp jedinců vytvořených podle tohoto agenta, jakým
způsobem se generuje populace takových jedinců, jaké genetické operátory budou
při~evolučním vývoji použité a jakým stylem probíhá transformace genotypu
jedince na nastavení odpovídajících aktuátorů robota. Agent zároveň uchovává
informaci o zvoleném typu evoluce, který určuje, zda evoluční algoritmus může
vyvíjet řízení robota, jeho morfologii nebo obojí.

Agent pro evoluční algoritmus vytváří jedince, jejichž genotyp se skládá ze
dvou vektorů. První z vektorů vždy obsahuje hodnoty, pomocí kterých agent
generuje na základě vstupu z testovacího prostředí odpovídající nastavení pro
aktuátory robota. Druhý z vektorů obsahuje hodnoty popisující délku těch částí
těla robota, u kterým jsme povolili jejich vývoj pomocí evolučního algoritmu.
Pokud jsme nepovolili vývoj žádné části těla, tento vektor zůstane prázdný.

\paragraph{Třída agenta}
Hlavní třídou tohoto modulu, tvořící šablonu pro všechny další definované
agenty, je třída \texttt{BaseAgent}. Všechny třídy popisující agenty mají
povinnost odvozovat od této třídy základního agenta. Součástí této třídy je
několik abstraktních metod (metody, které odvozená třída má povinnost
implementovat, aby byla použitelná). Výčet abstraktních metod agenta:

\begin{enumerate}[a)]
    \item metody využívané evolučním algoritmem:
        \begin{itemize}
            \item \texttt{generate\_population(population\_size)} -- metoda
                vytvářející populaci jedinců požadované velikosti,
            \item \texttt{get\_action(individual, step)} -- metoda
                zprostředkovávající transformaci části genotypu jedince
                (kterou funkce získá ze vstupního parametru \texttt{individual}) na
                nastavení pro aktuátory daného robota na základě vstupu z
                testovacího prostředí (simulační krok v testovacím prostředí --
                z parametru \texttt{step}),
            \item \texttt{selection(population, fitness\_values)} -- genetický
                operátor -- metoda s parametry populace jedinců a jejich
                fitness hodnotami, která nějakým způsobem (s využitím
                genetických operátorů selekce) vybere jedince a vrátí jejich
                seznam,
            \item \texttt{crossover(population)} -- genetický operátor --
                metoda s parametrem populace jedinců (označující skupinu
                rodičů), na které provede křížení genotypů a vrátí vytvořenou
                skupinu potomků,
            \item \texttt{mutation(population)} -- genetický operátor -- metoda
                do které jako parametr vstoupí skupina jedinců (potomků
                křížení), na kterých provede mutaci genotypu a vrátí
                zmutované potomky,
            \item \texttt{switch\_evo\_phase()} -- metoda využívána z hlavního
                modulu, který řídí evoluční algoritmus, sloužící pro vyhlášení
                změny typu evolučního vývoje (přechod mezi vývojem řízení a
                morfologie při odděleném vývoji řízení a~morfologie),
        \end{itemize}
    \item metody využívané pro vstupní rozhraní:
        \begin{itemize}
            \item \texttt{description()} -- metoda, do které můžeme vložit
                text, sloužící jako rozsáhlejší popisek agenta v \emph{GUI}.
        \end{itemize}
\end{enumerate}

Využití abstraktních metod se pro tuto implementaci hodí, protože tímto
způsobem můžeme v experimentech jednoduše zaměňovat typy využívaných
agentů a měnit tak průběh evolučního vývoje. 

\paragraph{Vlastní agent}
Uživatel může jednoduše přidávat vlastní agenty, vytvořením třídy odvozené
od třídy \texttt{BaseAgent} a implementováním potřebných metod. Pro
zjednodušení tohoto procesu, uživatel nemusí vlastnoručně programovat všechny
tyto metody, ale může využít připravené genetické operátory, implementované v
pomocném modulu \emph{gaOperators}, který si představíme v následujícím oddílu
\ref{imp:gaOperators}. Pokud uživatel nenajde takovou funkci, která by přesně
odpovídala jeho požadavkům, může si potřebný algoritmus dopsat sám, za dodržení
pravidel specifikovaných implementací třídy agenta.

\paragraph{Existující agenti}
V následujícím seznamu krátce představíme všechny dostupné agenty připravené
pro experimenty:

\label{imp:gaAgents.stepcyclehalfagent}
\label{imp:gaAgents.sinefuncfullagent}
\label{imp:gaAgents.sinefunchalfagent}
\label{imp:gaAgents.stepcyclehalfagent}
\label{imp:gaAgents.TFSagent}
\begin{itemize}
    \item \textbf{\emph{StepCycleHalfAgent}} -- agent, jehož genotyp je vektor předem
        zvolené délky pro polovinu aktuátorů robota, kde hodnoty v genotypu přímo
        popisují hodnoty nastavení aktuátorů. Tato nastavení jsou periodicky
        opakována v periodě zvolené délky vždy pro polovinu aktuátorů a pro
        druhou polovinu jsou symetricky přenesena a nastavena na opačné
        hodnoty (vynásobením hodnoty minus jedničkou -- všechny aktuátory mají
        povolený rozsah hodnot od $-1$ do $1$).

    \item \textbf{\emph{StepCycleFullAgent}} -- agent, podobný agentovi
        \emph{StepCycleHalfAgent}, generující do svého genotypu nastavení pro
        všechny aktuátory robota pro~určitý počet kroků. Tato nastavení se opět
        periodicky opakují.

    \item \textbf{\emph{SineFuncFullAgent}} -- agent, jehož genotyp popisuje
        parametry sinusové funkce pro každý aktuátor robota (amplituda,
        frekvence, posun v ose $x$ a posun v ose $y$). Nastavení aktuátorů je
        pak vygenerované výpočtem sinus funkce pro každý aktuátor v daném
        simulačním kroku (z celočíselného parametru\texttt{step} funkce
        \texttt{get\_action}), podle následující rovnice:
        \begin{equation}
            \text{nastavení aktuátoru} = f(step) = A\cdot\sin(\frac{2\pi\cdot step}{T} + \delta_x) + \delta_y
            \label{sinefunc}
        \end{equation}
        kde $T$ je perioda sinus funkce, $A$ je amplituda funkce a $\delta_x$ a
        $\delta_y$ jsou její posuny. Hodnota parametru \texttt{step} může být
        pro plynulejší přechody mezi nastaveními aktuátorů dělena na menší
        hodnoty.

    \item \textbf{\emph{SineFuncHalfAgent}} -- agent, podobný jako
        \emph{SineFuncFullAgent}, který má parametry sinusových funkcí pouze pro
        polovinu aktuátorů. Druhou polovinu generuje opět přenesením opačných
        hodnot z první poloviny. Pro výpočet hodnoty nastavení aktuátorů
        využívá stejné funkce, jako \emph{SineFuncFullAgent} (funkce
        (\ref{sinefunc})).

    \item \textbf{\emph{TFSAgent}} -- složitější agent než \emph{SineFuncFullAgent},
        využívající genotyp popisující zkrácenou Fourierovu transformaci pro
        každý aktuátor na generování požadovaného nastavení. Genotyp obsahuje
        parametry pro amplitudy a posuny pro vybraný počet sinus funkcí.
        Výpočet nastavení jednoho aktuátoru potom vypadá dle následující
        funkce (\ref{TFS_func}):

        \begin{equation}
            \text{nastavení aktuátoru} = f(step) = \sum_{i=1}^{N}A_i\cdot\sin\frac{i\cdot
            step\cdot2\pi}{T} + \delta_i
            \label{TFS_func}
        \end{equation}
        kde $N$ je pevný počet sinus funkcí, na které součet omezíme, $T$ je
        pevně zvolená perioda, $A_1,...,A_N$ jsou amplitudy sčítaných
        sinusoid a $\delta_i,...,\delta_N$ jsou jejich posuny,
    \item \textbf{\emph{NEATAgent}} -- agent, implementující algoritmus
        neuroevoluce -- NEAT (\emph{NeuroEvolution of Augmenting Topologies}),
        popsaný v základních pojmech v sekci \ref{NN - NEAT}. Naše implementace
        využívá python knihovnu pro NEAT -- \emph{neat-python}
        \citep{McIntyre_neat-python}.
\end{itemize}

Kromě zcela náhodného agenta a agenta využívajícího NEAT, se agenti snaží pro
urychlení evolučního vývoje předpokládat, že vhodné řešení bude v podobě
nějakého periodického pohybu a generují tedy výstupy pro nastavení aktuátorů
podle nějakých periodických funkcí. 

\subsection{Modul gaOperators} \label{imp:gaOperators}
Modul \emph{gaOperators} slouží pro usnadnění tvorby evolučních algoritmů
implementací řady nejpoužívanějších genetických operátorů použitelných v
metodách agentů (popsaných v předešlé sekci \ref{imp:gaAgents}). 

Seznam implementovaných operátorů (podrobný popis operátorů v sekci
\ref{Evoluční algoritmy - operátory}):
\begin{itemize}
    \item \texttt{roulette\_selection(pop, fitness\_values)} -- implementace
        \emph{ruletové selekce}, s argumenty populace jedinců a jejich fitness
        hodnoty. Vyžaduje, aby~všechny hodnoty \texttt{fitness\_values} byly
        nezáporné,
    \item \texttt{tournament\_selection(pop, fitness\_values, k)} --
        implementace \emph{turnajové selekce}, s argumenty populace
        jedinců, jejich fitness hodnoty a hodnotu $k$ určující velikost turnaje,
    \item \texttt{tournament\_prob\_selection(pop, fitness\_values, prob, k)}
        -- implementace pokročilé \emph{turnajové selekce}, kde umístění
        jedince v turnaji mezi $k$~náhodně vybranými jedinci určuje jeho
        pravděpodobnost na zvolení podle vzorce: 
        \begin{equation}
            p(X) = prob\cdot(1-prob)^{(X-1)}
        \end{equation}
        kde $X=1,...,k$ je pozice, na které se daný jedince umístil v turnaji a $prob$
        je vstupní parametr funkce, určující pravděpodobnost na zvolení
        prvního. Toto rozdělení pravděpodobností je normalizováno tak, aby pro
        každou volbu $k$ se sečetlo na jedničku. Následně je vektor
        pravděpodobností využit při náhodném výběru jednoho z jedinců v
        turnaji, 
    \item \texttt{crossover\_uniform(pop, agent)} -- implementace základního
        operátoru uniformního křížení, popsaného v sekci \ref{Evoluční
        algoritmy - operátory}, s argumenty populace jedinců a odkazem na
        zvoleného agenta, který pro metody udržuje další potřebné informace
        (např. sílu mutace jedinců, příznak označující povolení vývoje
        morfologie),
    \item \texttt{crossover\_single\_point(pop, agent)} -- implementace
        operátoru jednobodového křížení, popsaného v sekci \ref{Evoluční
        algoritmy - operátory},
    \item \texttt{uniform\_mutation(pop, agent)} -- implementace jednoduchého
        operátoru uniformní mutace (popsané v sekci \ref{Evoluční algoritmy -
        operátory}), využívající parametry agenta, který specifikuje
        pravděpodobnost mutace samotného jedince, pravděpodobnost mutace akcí a
        pravděpodobnost mutace částí těla (\emph{individual mutation
        probability}, \emph{action mutation probability}, \emph{body mutation
        probability}),
    \item \texttt{uniform\_shift\_mutation(pop, agent)} -- implementace
        upraveného operátoru uniformní mutace, využívajících stejných parametrů
        pravděpodobností jako předchozí operátor \texttt{uniform\_mutation}.
        Tento operátor provede mutaci dané hodnoty vygenerováním hodnoty malé
        změny z povoleného rozsahu (příklad -- náhodně zvolená
        $\delta\in[\frac{min}{0.05}, \frac{max}{0.05}]$), kterou přičte k
        původní mutované hodnotě ($a = a' + \delta$, kde $a'$ je mutovaná
        hodnota před mutací a $a$ hodnota po aplikování mutace). Výsledná
        hodnota je poté omezena do povoleného rozsahu.
\end{itemize}

\section{Třída experimentů} \label{imp:experimentsetter}
Pro usnadnění vytváření, ukládání a výběru experimentů jsme v modulu
\emph{experiment\_setter} implementovali vlastní jednoduchou třídu
\texttt{Experiments}. Tato~třída má za úkol být seznamem nadefinovaných
experimentů, které mohou být rychle načteny buď podle zvoleného názvu
experimentu, nebo podle jména funkce, vytvářející experiment.

Hlavní datovou strukturou třídy je slovník, který má jako klíče názvy
experimentů a jako hodnoty korespondující parametry experimentu (objekt třídy
\texttt{ExperimentParams}). Tento slovník je naplněn v době inicializace třídy
a uživatel do něj může přidat vlastní experimenty (je potřeba vytvořit záznam
ve slovníku experimentů s hodnotou odpovídajících parametrů experimentu).

Třída \texttt{Experiments} obsahuje, všechny experimenty předvedené v této
práci, ze kterých uživatel může brát inspiraci při vytváření vlastních. Samotný
experiment je popsán vždy ve vlastní funkci vracející parametry experimentu.
Jak může vypadat tvorba experimentu můžeme vidět v následující ukázce.

\begin{code}
def exp10_TFS_spotlike(self, run=True):
    robot = robots.SpotLike()
    agent = gaAgents.TFSAgent(robot, ...)
    note = "exp1.0"

    # __create_batch_dir - Funkce, která na základě zvoleného robota, 
    # agenta a zvolené poznámky vytvoří cestu, kam se uloží 
    # výsledky experimentu.
    batch_dir = self.__create_batch_dir(robot, agent, note) 

    # tvorba parametrů experimentu
    params = ExperimentParams(robot, 
                              agent,
                              population_size=100,
                              generation_count=500,
                              show_best=False,
                              save_best=True,
                              save_dir=batch_dir,
                              note="")

    # pokud je experiment tvořen přímo voláním funkce, vypiš info
    if run: 
        self.__exp_start_note()

    return params
\end{code}

Tato třída výrazně usnadňuje spouštění experimentů pro vstupní prostředí. Navíc
díky dalším metodám (pro kontrolu správného výběru experimentu a pro výpis
všech vytvořených experimentů) uživatel může pracovat s experimenty,
aniž~by měl potřebu znát obsah této třídy.

\section{Grafické rozhraní} \label{imp:GUI}
Pro nastavování a spouštění experimentů může uživatel využít jednoduché
grafické aplikace. Tento přístup je vhodný zejména pro prototypování nápadů na
experimenty. Uživatel v aplikaci může rychle vybírat a měnit parametry jak
agentů, robotů, tak samotného genetického algoritmu. Oproti tomu, použití
grafického rozhraní nemusí být vhodné v případech, že uživatel bude chtít
provádět větší množství předem připravených experimentů, při kterých běh
grafického rozhraní není potřeba.

\paragraph{Implementace GUI}
Implementace používá modul \emph{PySimpleGUI} \citep{pysimplegui}, umožňující
jednoduchý a rychlý vývoj grafických aplikací v Pythonu. 

\emph{PySimpleGUI} umožňuje vytvářet prvky rozhraní (např.
tlačítka, vstupní textová pole, ale i celá okna) uvnitř vlastních funkcí a
prvky pak vracet jako hodnotu funkce. To oproti jiným grafickým knihovnám
zlepšuje celkovou čitelnost a přehlednost kódu. Prvky rozhraní musí být v okně
vložené do rozložení~(\emph{layout}). Tato rozložení ale mohou být jednoduše
uložená v seznamech, díky schopnosti Pythonu pracovat se seznamy
heterogenních dat.

Naše grafická aplikace je rozdělená do několika sekcí:

% TODO: Change pics
\begin{itemize}
    \item \emph{Main} -- přehled informací o nastavovaném experimentu a
        spouštění experimentu (ukázka na obrázku \ref{imp:fig:GUI_main}),
    \item \emph{Robot select} -- sekce pro výběr robota (ukázka na obrázku
        \ref{imp:fig:GUI_robot}),
    \item \emph{Agent config} -- sekce pro výběr a nastavení parametrů agenta
        (ukázka na obrázku \ref{imp:fig:GUI_agent}),
    \item \emph{Evolution config} -- podrobnější úprava genetických operátorů a
        parametrů evolučního algoritmu (ukázka na obrázku \ref{imp:fig:GUI_evo}).
\end{itemize}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.6\textwidth]{../img/GUI_main_tab.jpg}
    \caption{Úvodní okno aplikace}
    \label{imp:fig:GUI_main}
\end{figure}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.6\textwidth]{../img/GUI_robot_tab.jpg}
    \caption{Okno pro volbu robota pro experiment}
    \label{imp:fig:GUI_robot}
\end{figure}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.6\textwidth]{../img/GUI_agent_tab.jpg}
    \caption{Okno pro volbu agenta pro experiment}
    \label{imp:fig:GUI_agent}
\end{figure}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.6\textwidth]{../img/GUI_evo_tab.jpg}
    \caption{Okno pro úpravu specifických nastavení agenta}
    \label{imp:fig:GUI_evo}
\end{figure}


Vytváření jednotlivých sekcí je oddělené do vlastních funkcí, které jsou pak
při inicializaci aplikace volány z rozložení hlavního okna.

Běh aplikace je tak, jak tomu u grafických aplikací bývá, zajištěn nekonečným
cyklem, který se opakuje vždy při příchodu nějaké události do aplikace (např.
kliknutí myší na tlačítko v okně). Modul \emph{PySimpleGUI} pracuje na základě
posílání zpráv o událostech. Tyto zprávy jsou po obdržení zpracovávány uvnitř
nekonečného cyklu a dle potřeby vyřešeny.

Určité sekce využívají napojení na pomocné moduly z centrálního modulu
\emph{RoboEvo} (popsané výše v sekci \ref{imp:roboevo}). Tohoto využíváme
hlavně, abychom umožnili rozsáhlejší modifikace jednotlivých pomocných modulů
(např. popis a nastavování parametrů agenta).

Pokud uživatel spustí vybraný experiment, proběhne proces, ve kterém se
z~navolených hodnot v aplikaci vytvoří parametry pro spuštění experimentu
(objekt třídy \texttt{ExperimentParams}), které následně předá modulu
\emph{RoboEvo}. Zároveň se vytvoří nové okno, které vykresluje graf a vypisuje
informace o právě běžícím experimentu. Z tohoto okna může uživatel v libovolném
okamžiku zažádat o~prezentaci jedince s dosud nejlepším řešením.

\paragraph{Ovládání GUI}
Bližší popis jednotlivých záložek a ovládání grafického rozhraní je v
uživatelské dokumentaci práce v~sekci o grafickém rozhraní \ref{doc_12_GUI}.

\section{Textové rozhraní} \label{imp:TUI}
Vedle grafického rozhraní lze knihovnu ovládat i pomocí zadávání příkazů do
příkazové řádky. Tento přístup ke knihovně se může hodit při vypracování
větších nebo vícero experimentů, kdy očekáváme, že experimenty poběží delší
dobu (několik hodin). Pro tento účel nepotřebujeme a ani by nebylo
výhodné po celou dobu sledovat okno grafické aplikace.

Textové rozhraní (TUI) je tedy vytvořené hlavně za účelem spouštění
experimentů. Proto toto rozhraní úzce spolupracuje se třídou experimentů
(popsanou výše v sekci \ref{imp:experimentsetter}). Rozhraní vytváří jednoduchý
způsob, jak vybírat a spouštět vyhodnocení dostupných experimentů.

\paragraph{Ovládání TUI}
Textové rozhraní ovládá uživatel z příkazové řádky s různými vstupními
argumenty. Seznam a~popis vstupních argumentů dostupných pro práci s rozhraním
společně s příklady využití se nacházejí v uživatelské dokumentaci v~sekci o
textovém rozhraní \ref{doc_13_TUI_ovladani}.

\paragraph{Implementace TUI}
Samotná implementace rozhraní je již velmi jednoduchá. Zpracovává uživatelské
vstupy z argumentů, které buď předává dál do korespondujících funkcí, nebo
hlásí a řeší problémy, které mohli při zadávání argumentů nastat.

\section{Problémy implementace} \label{imp:problems}
Absolutní většina implementace se vyvíjela podle plánu. Ale u stále aktivně
vyvíjeného modulu \emph{MuJoCo} jsme narazili na několik problémů. Tyto
problémy \textbf{neovlivňují} možnosti vytváření ani provádění experimentů.
Problémy zasahují pouze do práce a zacházení s vizualizačním prostředí.

V této sekci popíšeme problémy, se kterými jsme se setkali, kde je potká
uživatel a co to pro něj znamená. Pro problémy zároveň prezentujeme jednoduchou
opravu.

\paragraph{Zapínání vizualizace -- běžící simulací}
Prvním problémem je výchozí interní nastavení knihovny \emph{MuJoCo}, které
v momentě kdy začíná probíhat vizualizace zároveň spouští i simulaci robota.
Mohlo by se tedy jednoduše stát, že by uživatel ani nemusel zaregistrovat, že
vizualizace běhu robota je již spuštěna před tím, než vizualizace opět skončí.

Pro řešení tohoto problému jsme se rozhodli přidat jeden krok mezi poslední
interakci s naší platformou a vizualizačním prostředím. Uživatel je tak nucen
potvrdit v konzoli hlášku zmáčknutím \texttt{ENTER}. Po tomto potvrzení
vizualizace okamžitě začíná a uživatel má větší šanci si průběhu vizualizace
všimnout a včas ho začít ovládat.

\paragraph{Okno vizualizace -- překreslování nápovědy}
Druhý problém je čistě vizuální, ale pořád vhodný zmínit. Při vykreslování
vizualizačního okna si uživatel může zvolit, zda chce vykreslovat i průhledná
okno nápovědy a okno s informacemi ohledně rychlosti a času vykreslování. Tato
okna jsou v každém cyklu smazána a vykreslena znova. Pokud ale uživatel
simulaci zastaví, vykreslování stále běží (aby uživatel mohl pohybovat kamerou,
měnit nastavení atd.). V ten moment se přestanou okna nápovědy mazat, ale jsou
stále vykreslována dál v~nekonečném cyklu, dokud se simulace opět nerozběhne.

\paragraph{Ukončení vizualizace -- čištění \emph{glfw} zdrojů}
Poslední a hlavní problém nastává při ukončení vizualizace po doběhnutí
simulace. I při korektním ukončení prostředí vizualizace, knihovna
\emph{MuJoCo} hlásí varování a interní chyby. Tyto chyby jsou způsobeny snahou
grafického modulu \emph{glfw} o uvolňování zdrojů vizualizačního.

Uživatel se s tímto problémem setká při ukončování okna vizualizace, které do
konzole zahlásí upozornění na chyby v kódu s popisem chyby a místem, kde se
nachází. Tato upozornění bohužel nejsme schopni od uživatele skrýt. Na samotnou
funkcionalitu celé platformy nemají žádný vliv.

\subsection{Problémy a řešení}
Pro problémy jsme byli schopni najít velmi jednoduché opravy. Díky tomu,
že~\emph{MuJoCo} je open source knihovna, úprava na naší straně by byla možná.
V této práci jsme se ale rozhodli nechat všechny knihovny v jejich výchozím
stavu tak, jak je uživatel dostane z balíčkovacích manažerů. Tím zachováme
cenou vlastnost platformy, a to jednoduchost instalace (informace o instalaci
prostředí pro platformu v uživatelské dokumentaci v sekci \ref{doc_11_spust}).

\paragraph{Návrh opravy}
Všechny opravy můžeme vyřešit v jediném souboru modulu \emph{Gymnasium}.
V \emph{conda} nainstalovaných balíčcích můžeme najít modul \emph{Gymnasium} s
knihovnou \emph{MuJoCo}. Hledáme soubor \emph{mujoco\_rendering.py} v adresáři
\emph{MuJoCo} modulu na následující cestě. 
\begin{code}
# příklad cesty na Linuxovém systému
# <conda> = miniconda3
~/<conda>/envs/roboEvo/lib/<python_packages>/gymnasium/envs/mujoco
\end{code}

\paragraph{Oprava druhého problému}
Druhý problém lze vyřešit kopií jediného řádku. Nacházíme se ve
zmíněném skriptu v metodě \texttt{render} třídy \texttt{WindowViewer}. Metoda
končí práci vyčištěním \emph{překrytí} před začátkem dalšího cyklu pomocí
metody \texttt{self.\_overlays.clear()}. O pár řádků výše, při zastavení
simulace běží nekonečný cyklus, který toto čištění nedělá. 
\begin{code}
400.  if self._paused:                       
401.      while self._paused:                
402.          update()                      
403.          if self._advance_by_one_step:
...
\end{code}
Oprava je jednoduchá. Stačí přidat volání \texttt{self.\_overlays.clear()} na
začátek \texttt{update} metody definované uvnitř \texttt{render} metody.
\begin{code}
351.  def update():
+++       self._overlays.clear()
352.      # fill overlay items
353.      self._create_overlay()
...
\end{code}

\paragraph{Oprava třetího problému}
Řešení třetího problému je jednoduché. Chyba nastane v metodě
\texttt{free} třídy \texttt{WindowViewer} na řádku 330. Myslím si, že zde
nastane chyba, protože odkaz na \texttt{self.window} již nemusí platit, což
testuje podmínka hned nad tímto řádkem. Stačí tedy tento řádek posunout o jeden
tabulátor dál tak, aby byl součástí bloku podmínky.

\begin{code}
326.  def free(self):
327.      if self.window:
328.          if glfw.get_current_context() == self.window:
329.              glfw.make_context_current(None)
330.      +++ glfw.destroy_window(self.window)
331.      self.window = None
\end{code}


