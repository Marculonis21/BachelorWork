%%% Fiktivní kapitola s ukázkami sazby

\chapter{Základní pojmy}

V této kapitole vysvětlíme a rozebereme důležité pojmy, se kterými se v dalším
popisu práce budeme setkávat. Znalost těchto pojmů je potřebná pro pochopení
důvodů volby daných vybraných technologií a pro pochopení základního rozboru
implementace řešení, kterou popíšeme v následujících kapitolách.

V této kapitole nejdříve vysvětlíme základní teorii evolučních algoritmů (oddíl
\ref{Evoluční algoritmy}) a dále v oddíle \ref{Evoluční algoritmy -
implementace} si ukážeme již existující knihovny pracující nebo umožňující
pracovat s genetickými algoritmy. Poté, v oddílu \ref{NN} se podíváme na základ
teorie neuronových sítí a popíšeme pokročilejší evoluční algoritmy (NEAT v
oddílu \ref{NN - NEAT}, HyperNEAT v oddílu \ref{NN - HyperNEAT}) sloužící přímo
k evolučnímu vývoji těchto sítí. Dále popíšeme simulátory prostředí (oddíl
\ref{Simulované prostředí}) a fyzikální simulátory (oddíl \ref{Simulované
prostředí - f simulátory}), které využijeme pro simulaci při vyvíjení našich
robotů.

TODO: Fyzikální simulátory a sim prostředí

\section{Evoluční algoritmy} \label{Evoluční algoritmy}

TODO: POPIS EVOLUČNÍ ALGORITMY

\subsection{Existující implementace} \label{Evoluční algoritmy - implementace}

Pro vývoj řízení robotů budeme využívat evoluční algoritmy. Naše knihovna tedy
bude implementovat několik alespoň základních genetických operátorů,
používaných při vývoji jedinců a co nejjednodušeji umožňovat jejich konfiguraci
před spouštěním jednotlivých experimentů. Naším cílem je co možná nejvíce
zpřístupnit knihovnu, která má být výsledkem této práce, aby uživatel se
základní znalostí genetických algoritmů a programovacího jazyka byl schopný
pochopit běh algoritmu a v případě potřeby mohl jednoduše provádět zásahy do
jeho běhu. Není tedy naším cílem najít tu nejefektivnější knihovnu, nýbrž tu,
která přinese výhody jako přehlednost a snadnou úpravu algoritmů, bez větších
obtíží s implementací a pochopením knihovny.

Dále představíme několik knihoven implementujících nebo usnadňujících
implementaci genetických algoritmů nebo jejich částí. Celkem se podíváme na dvě
knihovny -- DEAP (sekce \ref{DEAP}) a Inspyred (sekce \ref{Inspyred}).
Existují další podobné knihovny (Pyevolve, PyGAD), které ale oproti DEAP a
Inspyred nepřináší mnoho dalších užitečných možností.

\subsubsection{DEAP} \label{DEAP}

DEAP (\emph{Distributed Evolutionary Algorithms in Python}) \citep{deapproject}
je open-source Python knihovna pro rychlou tvorbu a prototypování evolučních
algoritmů. Snaží se tvorbu evolučních algoritmů zjednodušit pomocí přímočarého
postupu, podobného pseudokódu, který je se základní znalostí knihovny poměrně
jednoduchý na porozumění. 

Knihovna je tvořena ze dvou hlavních struktur \texttt{creator}, který slouží k
vytváření genetických informací jedinců z libovolných datových struktur a
\texttt{toolbox}, který je seznamem nástrojů (genetických operátorů), které
mohou být použité při sestavování evolučního algoritmu. Dalšími menšími
strukturami jsou \texttt{algorithms} obsahující 4 základní typy algoritmů a
\texttt{tools} implementující další základní operátory (části operátorů), které
je posléze možné přidávat do \texttt{toolbox}. Pomocí těchto základních
stavebních bloků mohou uživatelé poměrně jednoduše začít tvořit skoro libovolné
evoluční algoritmy \citep{fortin2012deap}. 

Následuje ukázka kódu tvorby základních částí evolučního algoritmu pro
\emph{One Max} problém, popsaná v oficiální dokumentaci knihovny DEAP. V
\emph{One Max} problému máme populaci jedinců, kteří reprezentují vektor
binárních čísel předem zvolené délky. Cílem je potom vyvinout takového jedince,
který má na všech pozicích vektoru nastavené jedničky. 

Nejprve jsme v kódu importovali potřebné části knihovny. Dále využijeme
\texttt{creator} pro tvorbu specifických tříd, které budeme potřebovat pro
popis jedinců v našem evolučním algoritmu.

\paragraph{\texttt{Creator}} 
\texttt{Creator} je třída sloužící jako \emph{factory} pro uživatelem
definované třídy. Tedy s její pomocí můžeme vytvářet nové třídy za běhu
programu. To se hodí, protože různé problémy mohou vyžadovat velmi rozdílné
typy jedinců. Tvorba třídy probíhá pomocí funkce \texttt{create}, která jako
argumenty přijímá jméno vytvářené třídy, dále třídu, od které nová třída bude
dědit a poté může následovat řada argumentů, které mohou být využity jako další
argumenty naší nové třídy.

\begin{code}
creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)
\end{code}

První řádek popisuje tvorbu třídy \texttt{FitnessMax}, která dědí od třídy
\texttt{Fitness} knihovny DEAP a zároveň obsahuje argument \texttt{weights},
který specifikuje, že fitness bude maximalizovat jediný cíl (pomocí DEAP můžeme
specifikovat hned několik cílů najednou, ve kterých chceme, aby se jedinci
zlepšovali).

Na druhém řádku vytváříme třídu jedince \texttt{Individual}, která dědí od třídy
\texttt{list} a bude obsahovat parametr \texttt{fitness}, do které přiřadíme
vytvořenou třídu \texttt{FitnessMax}.

\paragraph{\texttt{Toolbox}}
Dále využijeme vlastní třídy pro tvorbu specifických typů, které budou
reprezentovat jedince a celou populaci. \texttt{Toolbox} se stane úložištěm pro
všechny objekty, které budeme při tvorbě evolučního algoritmu používat. Do
tohoto úložiště můžeme objekty přidávat funkcí \texttt{register} a můžeme je
odebrat funkcí \texttt{unregister}.

\pagebreak
\begin{code}
# založení úložiště 
toolbox = base.Toolbox()

# generátor atributů pro jedince
toolbox.register("attr_bool", random.randint, 0, 1)

# inicializace struktur jedince a populace
toolbox.register("individual", 
                 tools.initRepeat, 
                 creator.Individual, 
                 toolbox.attr_bool, 
                 100)
toolbox.register("population", 
                 tools.initRepeat, 
                 list, 
                 toolbox.individual)
\end{code}

Nejdříve jsme vytvořili \texttt{toolbox} jako úložiště pro naše funkce. Dále
jsme přidali generátor \texttt{toolbox.attr\_bool()}, tvořený z funkce
\texttt{random.randint()}, který když zavoláme, náhodně vygeneruje celé číslo
mezi 0 a 1.

Dále jsme přidali dvě inicializační funkce \texttt{toolbox.individual()} pro
inicializaci jedinců a \texttt{toolbox.population()} pro inicializaci celé
populace. 

Pro vytvoření jedince používáme funkci \texttt{tools.initRepeat()}, která jako
první argument přijímá kontejner (v našem případě třídu jedince, kterou jsme
definovali dříve jako potomka třídy \texttt{list}). Ten bude při inicializaci
naplněn funkcí \texttt{toolbox.attr\_bool()}, která se zavolá 100 krát, jak
specifikují následující dva argumenty. Při inicializaci celé populace budeme
postupovat stejně, jen jsme ještě v tento moment nespecifikovali, kolik jedinců
bude do populace vytvořeno.

\paragraph{Hodnotící funkce}
Hodnotící funkce je pro tento problém jednoduchá. Potřebujeme pouze spočítat,
kolik jedniček obsahuje daný jedinec (vektor binárních čísel).

\begin{code}
def evalOneMax(individual):
    return sum(individual)
\end{code}

\paragraph{Genetické operátory}
Knihovna umožňuje dva přístupy, jak můžeme využívat genetické operátory. Buď je
můžeme volat přímo z \texttt{tools}, nebo je nejdříve registrujeme do úložiště
\texttt{toolbox} a z něho je budeme používat. Registrace je brána jako
vhodnější varianta, protože to v budoucnu ulehčí proces, pokud bychom chtěli
měnit používané operátory.

\begin{code}
toolbox.register("evaluate", evalOneMax)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)
\end{code}

Ohodnocení populace bude zajišťovat funkce \texttt{toolbox.evaluate()}, tvořící
alias na dříve vytvořenou hodnotící funkci. Funkce \texttt{toolbox.mate()} je v
tomto příkladu alias za \texttt{tools.cxTwoPoint()}, což je knihovnou
připravená funkce provádějící dvoubodové křížení. Podobně tvoříme i funkce pro
mutaci jedinců (v tomto případě binární mutaci -- \texttt{tools.mutFlipBit}),
kde argument \texttt{indpb} určuje pravděpodobnost mutace jednotlivých
parametrů jedince a v poslední řadě funkci pro selekci (turnajová selekce s
turnajem mezi třemi jedinci).
        
\paragraph{Evoluce}
Když jsou všechny části připravené, vlastní evoluční algoritmus se vytvoří
kombinací jednotlivých definovaných částí, aplikováním registrovaných funkcí na
populaci nebo jedince dle potřeby. 

Na inicializované populaci se provádí evoluce, dokud nějaký z jedinců
nesplní zadaný úkol, nebo dokud evoluce nedosáhne určitého počtu generací. 

\paragraph{}
Pro stručnější popis zbytek kódu vynecháme, protože jsme si již předvedli
všechny části spojené s definováním evolučního algoritmu, které jsou specifické
pro práci s knihovnou DEAP. Úplnou ukázku lze najít v oficiální dokumentaci
knihovny \citep{deapproject}.

\paragraph{}
Podle článku \citep{fortin2012deap}, který porovnává několik Python modulů pro
usnadnění práce s evolučními algoritmy, je DEAP nejefektivnější,
tedy tvoří nejkratší kód, v porovnání počtu řádků potřebných pro tvorbu
algoritmu řešící \emph{One Max} problém z ukázky.

\subsubsection{Inspyred} \label{Inspyred}

Inspyred \citep{InspyredDocs} poskytuje většinu z nejpoužívanějších evolučních algoritmů a
dalších přírodou inspirovaných algoritmů (simulace reálných
biologických systémů -- např. optimalizace mravenčí kolonií) v jazyce
Python. 

Knihovna přichází s funkční implementací řady základních 
evolučních algoritmů ve formě komponentů (Python funkcí), které si uživatel
může sám upravovat, rozšiřovat, nebo je úplně nahradit vlastními funkcemi. Při
tvorbě algoritmu pak uživatel skládá dohromady několik komponentů, které
ovlivňují, jak celý vývoj bude probíhat.
Těmito komponenty jsou:
\begin{enumerate}[a)]
    \item komponenty specifické danému problému:
        \begin{itemize}
            \item \texttt{generator} -- určuje jak se generují řešení
                (jedinci),
            \item \texttt{evaluator} -- definuje jak se vypočítává fitness
                jedinců,
        \end{itemize}
    \item komponenty specifické danému danému evolučnímu algoritmu:
        \begin{itemize}
            \item \texttt{observer} -- definuje jak uživatel sleduje evoluci,
            \item \texttt{terminator} -- rozhoduje, kdy by měla evoluce
                skončit,
            \item \texttt{selector} -- rozhoduje, kteří jedinci by se měli stát
                rodiči další generace,
            \item \texttt{variator} -- definuje jak jsou potomci vytvořeni z
                rodičovských jedinců,
            \item \texttt{replacer} -- volí, kteří jedinci mají přežít do další
                generace,
            \item \texttt{migrator} -- jak se přenáší jedinci mezi různými
                populacemi/generacemi,
            \item \texttt{archiver} -- jak jsou jedinci ukládání mimo stávající
                populaci.
        \end{itemize}
\end{enumerate}

Libovolná z těchto komponent pak může být nahrazena odpovídající vlastní
implementací \citep{tonda2020inspyred}.

Následuje jednoduchý příklad z dokumentace knihovny Inspyred, který nám rychle
představí možnou práci s knihovnou. Budeme řešit problém srovnatelný s
problémem \emph{One Max} představeným u příkladu knihovny DEAP. Nyní je cílem,
aby hodnota vektoru v binárním zápisu byla co nejvyšší (opět chceme, aby
výsledný jedinec měl na všech místech vektoru nastavené jedničky). 

Na začátku se importuje knihovna Inspyred a modul \texttt{random}.

\paragraph{\texttt{Generator}}
Pro řešení budeme vytvářet vlastní generátor jedinců populace. Všechny
generátory knihovny Inspyred mají vždy stejné dva argumenty:
\begin{itemize}
    \item \texttt{random} -- objekt pro generování náhodných čísel,
    \item \texttt{args} -- slovník dalších argumentů, které můžeme libovolně
        přidat.
\end{itemize}

\begin{code}
def generate_binary(random, args):
    bits = args.get('num_bits', 8)
    return [random.choice([0, 1]) for i in range(bits)]
\end{code}

Zde vytváříme vlastní funkci \texttt{generate\_binary}, která bude sloužit jako
generátor jedinců. V této funkci nejdříve do proměnné \texttt{bits} načteme
hodnotu z argumentu \texttt{num\_bits} (s jeho definicí se setkáme později) a
poté vytvoříme jedince jako list, který naplníme náhodně zvolenými binárními
hodnotami.

\paragraph{\texttt{Evaluator}}
Podobně jako generátor, tak i pro vyhodnocení fitness jedinců vytvoříme vlastní
funkci. Funkce tohoto typu opět vyžadují dva argumenty:
\begin{itemize}
    \item \texttt{candidate} -- jedinec, kterého ve funkci vyhodnocujeme
    \item \texttt{args} -- slovník dalších argumentů, které můžeme libovolně
        přidat
\end{itemize}

V knihovně se často setkáme s dekorátory funkcí. Přesněji funkce, které tvoříme
pro \texttt{evaluator} vyžadují dekorátor \texttt{@evaluator}. Dekorátory se
používají, protože vytváříme funkce, které budou použité v rámci jiných
interních funkcí (pro příklad naše vlastní vyhodnocovací funkce pracuje pouze s
jedním jedincem, ale funkce se bude při vyhodnocení fitness interně používat
pro celou populaci).

\begin{code}
@inspyred.ec.evaluators.evaluator
def evaluate_binary(candidate, args):
    return int("".join([str(c) for c in candidate]), 2)
\end{code}

Vyhodnocení jedince tedy vezme všechny prvky jeho vektoru, přečte je a
vyhodnotí výstup jako binární zápis nějakého celého čísla. Toto číslo je potom
výstupní ohodnocení pro daného jedince.

\paragraph{Genetický algoritmu}
Vytvořili jsme všechny potřebné části, specifické pro tento problém a tedy je
můžeme použít pro vytvoření výsledného genetického algoritmu. Knihovna Inspyred
nabízí několik různých typů evolučních algoritmů (genetické algoritmy, evoluční
strategie, simulované žíhání a další). Pro tento problém vybereme
základní formu genetického algoritmu, který je nám v této knihovně dostupný.

\begin{code}
rand = random.Random()
ga = inspyred.ec.GA(rand)
ga.observer = inspyred.ec.observers.stats_observer
ga.terminator = inspyred.ec.terminators.evaluation_termination
\end{code}

Zde nejprve vytváříme objekt pro generování náhodných čísel, který bude
využíván v algoritmu. Na druhém řádku pak vytváříme objekt samotného
genetického algoritmu. Jak jsme zmínili výše, všechny algoritmy mají určité
komponenty, které uživatel může měnit za jiné, nebo je celé sám upravovat. Pro
ukázku zde měníme komponenty \texttt{observer} a \texttt{terminator}. Pro
\texttt{observer} volíme připravený \texttt{stats\_observer}, což je funkce,
která v průběhu algoritmu bude vypisovat statistiky z běhu evoluce. Výstup
tohoto \texttt{observeru} bude mít následující podobu:

\begin{code}
Generation Evaluation   Worst    Best   Median   Average     Std Dev
---------- ---------- ------- ------- -------- --------- -----------      
         0        100       6    1016    564.5    536.02  309.833954

Generation Evaluation   Worst    Best   Median   Average     Std Dev
---------- ---------- ------- ------- -------- --------- -----------     
         1        200      29    1021    722.5    675.22  247.645576
\end{code}

Zároveň měníme i \texttt{terminator} za funkci \texttt{evaluation\_termination},
která jednoduše zahlásí, že evoluce má skončit, pokud evoluce dosáhla
maximálního počtu vyhodnocení.

\paragraph{Evoluce}
Samotné spuštění a vyhodnocení evoluce je pak velmi jednoduché.

\begin{code}
final_pop = ga.evolve(evaluator=evaluate_binary,
                      generator=generate_binary,
                      max_evaluations=1000,
                      num_elites=1,
                      pop_size=100,
                      num_bits=10)

final_pop.sort(reverse=True)
\end{code}

Genetický algoritmus se lehce spustí pomocí funkce \texttt{evolve}, které předáme
požadované parametry jako náš zvolený \texttt{evaluator} a \texttt{generator},
dále pro \texttt{terminator} vkládáme maximální počet vyhodnocení, které chceme
při vývoji dovolit. Dále je možné pro tyto algoritmy specifikovat jevy jako
třeba elitismus. V poslední řadě \texttt{pop\_size} určuje velikost populace,
se kterou bude evoluce pracovat a vkládáme zde dříve zmíněný argument
\texttt{num\_bits}, určující velikost vektoru jedince. 

Další informace o příkladu a jednotlivých funkcích lze nalézt v oficiální
dokumentaci Inspyred \citep{InspyredDocs}.

% \subsubsection{PyEvolve} \label{PyEvolve}

\subsubsection{Porovnání} \label{GA - Porovnání}
Při srovnání těchto knihoven jsme převážně sledovali jak intuitivní práce s
nimi je. Cílem této práce je vytvořit co možná nejvíce otevřenou platformu, se
kterou bude moci uživatel provádět experimenty při vývoji řízení robotů.
Uživatel se základní znalostí evolučních algoritmů by tak měl být schopný
jednoduše pochopit všechny části knihovny a pokud by měl potřebu, sám si
doplnit nějaké specifické části. 

Z vlastního pohledu, ačkoli knihovna DEAP umožňuje tvorbu asi
libovolného evolučního algoritmu velmi kompaktním způsobem, potřeba pochopit a
seznámit se s procesem tvorby vlastních tříd a objektů, na kterém je DEAP
postavený, je poměrně velkou překážkou pro možného nového uživatele naší
knihovny, který by si mohl chtít upravit proces evolučních algoritmů dle
svých požadavků. Ačkoli méně kompaktní, řešení knihovny Inspyred
\ref{Inspyred}, které dělí algoritmy do základních stavebních bloků, kde každá
část může být se základní znalostí Pythonu pozměněna, se mi pro náš účel
zamlouvá více. Inspyred ale zároveň implementuje řadu dalších algoritmů, které
by v našem případě vůbec nemusely být využitelné a pouze by mohly zvyšovat
minimální množství znalostí potřebných k práci s naší knihovnou.

Na základě vyzkoušených a předvedených knihoven, které se dle různých zdrojů
\citep{fortin2012deap} zdály jako nejvhodnější pro naše využití, jsme se
rozhodli inspirovat se knihovnou Inspyred (stylem, jakým knihovna dělí
algoritmus na základní stavební bloky) a vytvořit vlastní implementaci většiny
základních stavebních bloků, které bude možné použít při tvorbě vlastních
evolučních algoritmů v naší knihovně. Tyto bloky budou co možná nejvíce obecné
a snadno konfigurovatelné funkce s předepsaným výstupním typem, aby uživatel
mohl snadněji porozumět implementaci každého z bloků a zároveň aby měl možnost
vytvářet vlastní bloky (Python funkce) a ty jednoduše zapojit do evolučního
algoritmu, právě tak jak tomu je v knihovně Inspyred. 

Celý projekt je směřován zároveň jako možný studijní materiál, a tak navíc
věřím, že pro studenty bude možnost vidět v kódu funkční implementaci
jednotlivých částí algoritmů tak, jak běží na pozadí experimentů přínosnější a
ulehčí to jejich další experimenty, třeba i s implementací vlastních bloků
evolučních algoritmů.

\section{Neuronové sítě} \label{NN}
\section{NEAT} \label{NN - NEAT}
\section{HyperNEAT} \label{NN - HyperNEAT}

\section{Simulované prostředí} \label{Simulované prostředí}

Jelikož chceme vyvíjet řízení robotů založené na interakcích s prostředím, je
pro tuto práci důležité vybrat vhodný simulátor prostředí, založený na
skutečných fyzikálních zákonech. Přáli bychom si mít možnost jednoduše
konfigurovat co nejvíce vlastností prostředí a zároveň mít co nejjednodušší
přístup k morfologii simulovaných robotů. Zároveň chceme, abychom měli možnost
do morfologie robotů nějakým způsobem zasahovat i v průběhu evolučního vývoje a
aktivně ji za běhu měnit. Jelikož plánujeme v prostředí provádět experimenty s
různými typy robotů, používajícími různé styly pohybu (typy motorů, kloubů,
tvarů končetin, atd.), je potřebné, aby fyzikální simulátor (\emph{fyzikální
řešič=solver}) byl schopný simulovat i složitější typy robotů. Takovými mohou
být právě třeba kráčející roboti, neboli roboti používající k pohybu končetiny
připomínající nohy, na rozdíl od jednodušších typů robotů, kteří se mohou
pohybovat pomocí kol, jejichž simulace bývá mnohdy jednodušší. 

Stejně tak, jak potřebujeme umožnit simulaci složitějších robotů, protože
nebudeme mít možnost vlastnoručně kontrolovat každý parametr, který bude při
vývoji robotům přiřazen, potřebujeme zajistit, aby fyzikální simulátor zvládal
velké rozsahy parametrů a simulace zůstala s těmito parametry stabilní. Zároveň
chceme, aby simulátor v prostředí byl deterministický, což umožní, že
předváděné experimenty můžeme dle potřeby opakovat a výsledky tak náležitě
prezentovat. 

Evoluční algoritmy jsou velmi lehce paralelizovatelné a tedy pro
urychlení procesu vývoje a experimentů bude pro nás výhodné, pokud by simulace
zvládala paralelní běh na více vláknech (více simulací, každá na vlastním
vlákně). V poslední řadě pro lehčí integraci do vlastního modulu bude užitečné,
aby modul spravující zvolený simulátor byl open-source, což nám dá volnost v
případě, že si budeme chtít chování systémů v prostředí nějak vlastnoručně
upravit.

Při hledání simulátorů prostředí, které by vyhovovali našim požadavkům a
umožňovali kontrolu a ovládání prostředí prostřednictvím zvoleného jazyka
Python, jsme narazili na několik možností. Omezený výčet těchto simulátorů zde
popíšeme -- Gazebo (v oddílu \ref{Gazebo}), Webots (v oddílu \ref{Webots}) a
CoppeliaSim (v oddílu \ref{CoppeliaSim}). Dále se pak podíváme na několik
nejpoužívanějších fyzikálních simulátorů \ref{Simulované prostředí - f
simulátory}.

\subsubsection{Gazebo} \label{Gazebo}
Gazebo \citep{gazeborobotics} je sada open-source víceplatformních knihoven pro
vývoj, výzkum a aplikaci robotů, která vznikla v roce 2002. Umožňuje kompletní
kontrolu nad simulací dynamického 3D prostředí s více agenty a generování dat
ze simulovaných senzorů. Fyzikálně korektní interakce v prostředí pak od
začátku projektu zajišťuje známý fyzikální simulátor ODE (viz sekce \ref{ODE}),
nad kterým Gazebo tvoří abstraktní vrstvu, umožňující snazší tvorbu
simulovaných objektů různých druhů. V dnešní době je stále výchozím fyzikálním
simulátorem ODE, nicméně uživatel již může vybrat celkem ze čtyř různých
simulátorů -- Bullet (sekce \ref{Bullet}), Simbody, Dart (sekce \ref{Dart}) a
ODE. Uživatel s knihovnou pracuje prostřednictvím grafického rozhraní založené
na knihovně Open Scene Graph používající OpenGL, nebo prostřednictvím příkazové
řádky. Prostředí a roboti mohou být tvořené buď z grafického rozhraní
prostředí, nebo v textovém formátu XML. Limitací Gazebo je pak chybějící
možnost rozdělit simulace mezi vícero vláken kvůli vnitřní architektuře spojené
s fyzikální simulací \citep{koenig2004design}. 

\subsubsection{Webots} \label{Webots}
Webots \citep{Webots} je open-source víceplatformní robustní a deterministický
robotický simulátor vyvíjený od roku 1998, umožňující programování a testování
virtuálních robotů mnoha různých typů a jednoduchou následnou aplikaci softwaru
na reálné roboty. Simulátor je možné použít pro simulaci prostředí s vícero
agenty najednou s možnostmi lokální i globální komunikace mezi agenty. Výpočty
fyzikálních interakcí zajišťuje fyzikální simulátor ODE. Pro vývoj robotů a
prostředí je možné využít řady programovacích jazyků a to C, C++, Python, Java,
MATLAB nebo ROS (\emph{Robot Operating System}). Prostředí umožňuje práci v
grafickém rozhraní a vizualizaci simulací pomocí OpenGL. Knihovna dále nabízí
využití připravených modelů robotů, vlastní editor robotů a map a možnosti
vložení vlastních robotů z 3D modelovacích softwarů v CAD formátu
\citep{michel2004cyberbotics}.

\subsubsection{CoppeliaSim} \label{CoppeliaSim}
CoppeliaSim \citep{coppeliaSim} (původně známý pod jménem \emph{V-REP} =
\emph{Virtual Robot Experimentation Platform}) je víceplatformní simulační
modul pro vývoj, testování a jednoduchou aplikaci softwaru pro roboty. Dovoluje
vývoj ovladačů pomocí 7 různých programovacích jazyků a ulehčuje jejich
aplikace v simulovaných a skutečných robotech. Simulaci ovladačů je možno
jednoduše rozdistribuovat mezi vícero vláken dokonce vícero strojů, což
urychluje vývoj a snižuje nároky na procesor v době simulace. Navíc je možné
vyvíjený ovladač nechat v době simulací běžet na vlastním na dálku připojeném
robotovi, co dále ulehčuje přenos finální verze ovladačů od vývoje do
skutečného světa. Prostředí umožňuje práci s širokou řadou typů objektů, druhů
kloubů, senzorů a dalších objektů obvykle používaných při vývojích robotických
ovladačů. Obsahuje lehce použitelný editor prostředí a robotů samotných s řadou
předem vytvořených modelů, které může uživatel hned využít. Modely zároveň
mohou být přidány v řadě různých formátů (XML, URDF, SDF). Prostředí
podporuje pět různých fyzikálních simulátorů (Bullet, ODE, MuJoCo (v sekci
\ref{MuJoCo}), Vortex (v sekci \ref{Vortex}), Newton), mezi kterými si uživatel
může vybrat dle potřeb přesnosti (reálnosti), rychlosti a dalších možností
jednotlivých fyzikálních simulátorů \citep{nogueira2014comparative}.

\subsection{Fyzikální simulátory} \label{Simulované prostředí - f simulátory}

V této podkapitole se podíváme na základní popis a možné výhody a nevýhody
jednotlivých fyzikálních simulátorů, na které jsme narazili při hledání
simulátorů prostředí.

\subsubsection{ODE} \label{ODE}
ODE (\emph{Open Dynamics Engine}) \citep{opendynamicsengine} je víceplatformní
open-source fyzikální simulátor, jehož vývoj začal v roce 2001. Je vhodný pro
simulaci pevných těles s různými druhy kloubů a pro detekci kolizí. Byl navržen
pro využití v interaktivních nebo real-time simulacích, upřednostňující
rychlost a stabilitu nad fyzikální přesností \citep{smith2007open}. Vyžaduje
používat menší simulační kroky kvůli stabilitě. Hodí se pro simulaci vozidel,
pochodujících robotů a virtuálních prostředí. Má široké využití v počítačových
hrách a 3D simulačních nástrojích \citet{coppeliarobotics}.

\subsubsection{Bullet} \label{Bullet}
Bullet je open-source fyzikální knihovna, podporující detekci kolizí a simulaci
pevných a měkkých těles. Bullet je používán jako fyzikální simulátor pro hry,
vizuální efekty a robotiku \citep{coumans}. Byl použit jako hlavní fyzikální
simulátor pro simulaci NASA \emph{Tensegrity} robotů (s vlastními úpravami pro
simulaci měkkých těles, kvůli nerealistickým metodám řešení simulace provazů)
\citep{izadi2018simulating}.

\subsubsection{Dart} \label{Dart}
Dart (\emph{Dynamic Animation and Robotics Toolkit}) je víceplatformní
open-source knihovna pro simulace a animace robotů. Od předchozích se odlišuje
stabilitou a přesností, díky zobecněné reprezentaci souřadnic pevných těles v
simulaci. Na rozdíl od ostatních fyzikálních simulátorů, aby dal vývojáři plnou
kontrolu nad simulací, umožňuje Dart plný přístup k interním hodnotám simulace.
Zároveň se díky línému vyhodnocování hodí pro vývoj real-time ovladačů pro
roboty \citep{lee2018dart}.

\subsubsection{MuJoCo} \label{MuJoCo}
MuJoCo (\emph{Multi-Joint Dynamics with Contact}) \citep{deepmind_2021} je
open-source fyzikální simulátor pro vývoj v oblasti robotiky, biomechaniky a
dalších. Často je využíváno pro testování a porovnávání různých metod
navrhování robotických systémů jako jsou třeba evoluční algoritmy nebo metody
zpětnovazebného učení \citep{salimans2017evolution}. V simulacích je pro roboty
možné nakonfigurovat využití mnoha druhů aktuátorů, včetně těch simulující
práci svalů a k dispozici je i velké množství kloubů. Simulátor zároveň
umožňuje velký nárůst v rychlosti běhu simulace za pomoci plné podpory
paralelizace na všech dostupných vláknech a stabilitě simulace i při velmi
velkých simulačních krocích \citep{todorov2012mujoco}. Zároveň nabízí
jednoduchý styl, jakým si může uživatel konfigurovat všechny detaily simulace a
samotných simulovaných robotů pomocí jednoduchých XML konfiguračních souborů
(XML formát modelů \emph{MJCF}). V komplexním rozboru řady četně používaných
fyzikálních simulátorů byl simulátor MuJoCo hodnocen jako jeden z nejlepších co
se týče stability, přesnosti a rychlosti simulací. Další výhodou zlepšující
přesnost tohoto simulátoru je, že MuJoCo pro simulaci používá kloubní
souřadnicový systém, který předchází narušení fyzikálních pravidel a tedy
nepřesností v kloubech \citep{erez2015simulation}.

\subsubsection{Vortex} \label{Vortex}
Vortex je uzavřený, komerční fyzikální simulátor určený pro tvorbu
reálnému světu odpovídajících simulací. Obsahuje mnoho parametrů,
umožňující nastavení reálných fyzikálních parametrů dle potřeb,
většinou industriálních a výzkumných aplikací \citep{coppeliarobotics}
\citep{yoon2023comparative}.

\subsubsection{Porovnání simulátorů} \label{Simulátory - Porovnání}
V dnešní době se nám nabízí velké množství potencionálních kandidátů, vhodných
k využití pro naši aplikaci. Prakticky každý z open-source simulátorů, které
jsme našli a předvedli, by bylo možné použít pro simulaci robotů složitosti,
jakou máme předběžně v plánu. Hlavním z rozhodujících faktorů pro tento projekt
bude jak jednoduše půjde prostředí používat pro vývoj pomocí genetických
algoritmů. Chceme tedy nějaký jednoduchý přístup k simulaci a ovládání robotů,
rychlost a přesnost simulace. 

Opět většina ze simulátorů prostředí toto nabízí. Osobně se nám ale nejvíce
zalíbilo MuJoCo. Díky nedávnému otevření fyzikálního simulátoru MuJoCo a změně
prostředí (nejprve do \textbf{OpenAI Gym} a nyní do \textbf{Farama Foundation
Gymnasium}) jsme dostali možnost využít jednoduché Python API pro ovládání
robotů a zároveň konfiguraci celé simulace. 

Tato abstrakce od vlastní simulace je pro tuto práci velmi přínosná, protože se
především chceme zajímat o vývoj řízení robotů pomocí evolučních algoritmů.
Řešit zároveň složité ovladače robotů, které by se mohly lišit pro různé typy
robotů, by mohlo bezdůvodně komplikovat celý proces spojení evolučních
algoritmů s řízením robotů. Takové věci by pak mohly být problematické pro
možného uživatele, který by si chtěl sám evoluční algoritmy upravovat.

MuJoCo se zároveň ukazuje jako jeden z nejlepších volně dostupných fyzikálních
simulátorů dnes. Z výsledků článku testujících různé vlastnosti známých fyzikálních
simulátorů \citet{erez2015simulation} vychází, že MuJoCo má navrch jak v
rychlosti, tak ve kvalitě simulací. Zároveň interně využívá kloubní
souřadnicový systém, který je přesnější, protože zabraňuje nepřesnostem v
kloubech. To se hodí o to více, když v této práci chceme vyvíjet hlavně
kráčející roboty, u kterých můžeme mít i větší počty kloubů. 

Simulátor MuJoCo a roboti, které můžeme používat, je zároveň možné
jednoduše konfigurovat pomocí vlastního XML formátu a spojení s Python API
navíc umožní tyto konfigurace provádět jak často bude potřeba.
